generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ENUMS - Type Safety Guards

enum Source {
  API
  IMPORT
  BACKFILL
}

enum Term {
  SHORT_TERM
  MEDIUM_TERM
  LONG_TERM
}

enum BucketType {
  DAY
  WEEK
  MONTH
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// USER & AUTH

model User {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  displayName     String?  @map("display_name")
  email           String?
  imageUrl        String?  @map("image_url")
  country         String?
  createdAt       DateTime @default(now()) @map("created_at")
  lastIngestedAt  DateTime? @map("last_ingested_at")
  lastLoginAt     DateTime? @map("last_login_at")
  topStatsRefreshedAt DateTime? @map("top_stats_refreshed_at")
  
  // Denormalized stats for O(1) queries (updated via atomic increments)
  totalPlayCount   Int    @default(0) @map("total_play_count")
  totalListeningMs BigInt @default(0) @map("total_listening_ms")

  auth            SpotifyAuth?
  settings        UserSettings?
  listeningEvents ListeningEvent[]
  trackStats      UserTrackStats[]
  artistStats     UserArtistStats[]
  timeBucketStats UserTimeBucketStats[]
  hourStats       UserHourStats[]
  importJobs      ImportJob[]
  spotifyTopTracks SpotifyTopTrack[]
  spotifyTopArtists SpotifyTopArtist[]

  @@map("users")
}

model SpotifyAuth {
  userId              String    @id @map("user_id")
  refreshToken        String    @map("refresh_token")
  scopes              String
  lastRefreshAt       DateTime  @default(now()) @map("last_refresh_at")
  isValid             Boolean   @default(true) @map("is_valid")
  consecutiveFailures Int       @default(0) @map("consecutive_failures")
  lastFailureAt       DateTime? @map("last_failure_at")
  lastFailureReason   String?   @map("last_failure_reason")

  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("spotify_auth")
}

// MUSIC CATALOG (Global, Shared Across Users)

model Track {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  durationMs      Int      @map("duration_ms")
  albumId         String?  @map("album_id")
  previewUrl      String?  @map("preview_url")

  album           Album?   @relation(fields: [albumId], references: [id])
  artists         TrackArtist[]
  listeningEvents ListeningEvent[]
  userStats       UserTrackStats[]
  spotifyTopTracks SpotifyTopTrack[]

  @@index([spotifyId])
  @@index([albumId]) // FK index: "Find all tracks in Album X"
  @@map("tracks")
}

model Artist {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  imageUrl        String?  @map("image_url")
  genres          String[] @default([])

  tracks          TrackArtist[]
  userStats       UserArtistStats[]
  spotifyTopArtists SpotifyTopArtist[]

  @@index([spotifyId])
  @@index([genres], type: Gin) // Fast array containment queries
  @@map("artists")
}

model Album {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  imageUrl        String?  @map("image_url")
  releaseDate     String?  @map("release_date")

  tracks          Track[]

  @@index([spotifyId])
  @@map("albums")
}

model TrackArtist {
  trackId         String   @map("track_id")
  artistId        String   @map("artist_id")

  track           Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  artist          Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([trackId, artistId])
  @@index([artistId]) // FK index: "Find all tracks for Artist X"
  @@map("track_artists")
}

model ListeningEvent {
  id              String   @default(cuid()) // Will be replaced with UUID v7 in app layer
  userId          String   @map("user_id")
  trackId         String   @map("track_id")
  playedAt        DateTime @map("played_at") // Cast to TIMESTAMPTZ in post-migration
  msPlayed        Int      @map("ms_played")
  isEstimated     Boolean  @default(true) @map("is_estimated")
  isSkip          Boolean  @default(false) @map("is_skip")
  source          Source   @default(API)
  createdAt       DateTime @default(now()) @map("created_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track           Track    @relation(fields: [trackId], references: [id])

  @@id([id, playedAt]) // Composite PK enables partitioning by playedAt
  @@unique([userId, trackId, playedAt])
  @@index([userId, playedAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([trackId]) // FK index for cascade deletes
  @@map("listening_events")
}

model UserTrackStats {
  userId          String   @map("user_id")
  trackId         String   @map("track_id")
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")
  lastPlayedAt    DateTime? @map("last_played_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track           Track    @relation(fields: [trackId], references: [id])

  @@id([userId, trackId])
  @@index([userId, playCount(sort: Desc)])
  @@index([trackId]) // FK index for cascade deletes
  @@map("user_track_stats")
}

model UserArtistStats {
  userId          String   @map("user_id")
  artistId        String   @map("artist_id")
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist          Artist   @relation(fields: [artistId], references: [id])

  @@id([userId, artistId])
  @@index([userId, playCount(sort: Desc)])
  @@index([artistId]) // FK index for cascade deletes
  @@map("user_artist_stats")
}

model UserTimeBucketStats {
  userId          String     @map("user_id")
  bucketType      BucketType @map("bucket_type")
  bucketDate      DateTime   @map("bucket_date")
  playCount       Int        @default(0) @map("play_count")
  totalMs         BigInt     @default(0) @map("total_ms")
  uniqueTracks    Int        @default(0) @map("unique_tracks")

  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, bucketType, bucketDate])
  @@index([userId, bucketType, bucketDate(sort: Desc)])
  @@map("user_time_bucket_stats")
}

model UserHourStats {
  userId          String   @map("user_id")
  hour            Int
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, hour])
  @@map("user_hour_stats")
}

model ImportJob {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  fileName        String    @map("file_name")
  status          JobStatus @default(PENDING)
  totalEvents     Int       @default(0) @map("total_events")
  processedEvents Int       @default(0) @map("processed_events")
  errorMessage    String?   @map("error_message")
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime  @default(now()) @map("created_at")

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("import_jobs")
}

model UserSettings {
  userId              String   @id @map("user_id")
  isPublicProfile     Boolean  @default(false) @map("is_public_profile")
  shareTopTracks      Boolean  @default(true) @map("share_top_tracks")
  shareTopArtists     Boolean  @default(true) @map("share_top_artists")
  shareListeningTime  Boolean  @default(true) @map("share_listening_time")
  emailNotifications  Boolean  @default(false) @map("email_notifications")
  timezone            String   @default("UTC")
  updatedAt           DateTime @updatedAt @map("updated_at")

  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model MetadataRefreshLog {
  id              String   @id @default(cuid())
  entityType      String   @map("entity_type")
  entityId        String   @map("entity_id")
  lastRefreshedAt DateTime @default(now()) @map("last_refreshed_at")
  nextRefreshAt   DateTime? @map("next_refresh_at")
  errorCount      Int      @default(0) @map("error_count")

  @@unique([entityType, entityId])
  @@index([nextRefreshAt])
  @@map("metadata_refresh_log")
}


model SpotifyTopTrack {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  trackId   String   @map("track_id")
  term      Term
  rank      Int
  updatedAt DateTime @updatedAt @map("updated_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track     Track    @relation(fields: [trackId], references: [id])

  @@unique([userId, term, rank])
  @@unique([userId, term, trackId])
  @@index([trackId]) // FK index for cascade deletes
  @@map("spotify_top_tracks")
}

model SpotifyTopArtist {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  artistId  String   @map("artist_id")
  term      Term
  rank      Int
  updatedAt DateTime @updatedAt @map("updated_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist    Artist   @relation(fields: [artistId], references: [id])

  @@unique([userId, term, rank])
  @@unique([userId, term, artistId])
  @@index([artistId]) // FK index for cascade deletes
  @@map("spotify_top_artists")
}
