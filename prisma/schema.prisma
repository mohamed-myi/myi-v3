generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Source {
  API
  IMPORT
  BACKFILL
}

enum Term {
  SHORT_TERM
  MEDIUM_TERM
  LONG_TERM
}

enum BucketType {
  DAY
  WEEK
  MONTH
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum PlaylistCreationMethod {
  SHUFFLE
  TOP_50_SHORT
  TOP_50_MEDIUM
  TOP_50_LONG
  TOP_50_ALL_TIME
  TOP_K_RECENT
}

enum PlaylistJobStatus {
  PENDING
  CREATING
  ADDING_TRACKS
  UPLOADING_IMAGE
  COMPLETED
  FAILED
}

enum ShuffleMode {
  TRULY_RANDOM
  LESS_REPETITION
}

model User {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  displayName     String?  @map("display_name")
  email           String?
  imageUrl        String?  @map("image_url")
  country         String?
  isDemo          Boolean  @default(false) @map("is_demo")
  createdAt       DateTime @default(now()) @map("created_at")
  lastIngestedAt  DateTime? @map("last_ingested_at")
  lastLoginAt     DateTime? @map("last_login_at")
  topStatsRefreshedAt DateTime? @map("top_stats_refreshed_at")
  
  // Denormalized stats for O(1) queries (updated via atomic increments)
  totalPlayCount   Int    @default(0) @map("total_play_count")
  totalListeningMs BigInt @default(0) @map("total_listening_ms")

  auth            SpotifyAuth?
  settings        UserSettings?
  listeningEvents ListeningEvent[]
  trackStats      UserTrackStats[]
  artistStats     UserArtistStats[]
  timeBucketStats UserTimeBucketStats[]
  hourStats       UserHourStats[]
  importJobs      ImportJob[]
  playlistJobs    PlaylistJob[]
  spotifyTopTracks SpotifyTopTrack[]
  spotifyTopArtists SpotifyTopArtist[]

  @@map("users")
}

model SpotifyAuth {
  userId              String    @id @map("user_id")
  refreshToken        String    @map("refresh_token")
  scopes              String
  lastRefreshAt       DateTime  @default(now()) @map("last_refresh_at")
  isValid             Boolean   @default(true) @map("is_valid")
  consecutiveFailures Int       @default(0) @map("consecutive_failures")
  lastFailureAt       DateTime? @map("last_failure_at")
  lastFailureReason   String?   @map("last_failure_reason")

  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("spotify_auth")
}

model Track {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  durationMs      Int      @map("duration_ms")
  albumId         String?  @map("album_id")
  previewUrl      String?  @map("preview_url")

  album           Album?   @relation(fields: [albumId], references: [id])
  artists         TrackArtist[]
  listeningEvents ListeningEvent[]
  userStats       UserTrackStats[]
  spotifyTopTracks SpotifyTopTrack[]

  @@index([spotifyId])
  @@index([albumId])
  @@map("tracks")
}

model Artist {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  imageUrl        String?  @map("image_url")
  genres          String[] @default([])

  tracks          TrackArtist[]
  userStats       UserArtistStats[]
  spotifyTopArtists SpotifyTopArtist[]

  @@index([spotifyId])
  @@index([genres], type: Gin)
  @@map("artists")
}

model Album {
  id              String   @id @default(cuid())
  spotifyId       String   @unique @map("spotify_id")
  name            String
  imageUrl        String?  @map("image_url")
  releaseDate     String?  @map("release_date")

  tracks          Track[]

  @@index([spotifyId])
  @@map("albums")
}

model TrackArtist {
  trackId         String   @map("track_id")
  artistId        String   @map("artist_id")

  track           Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  artist          Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([trackId, artistId])
  @@index([artistId])
  @@map("track_artists")
}

model ListeningEvent {
  id              String   @default(cuid()) // Will be replaced with UUID v7 in app layer
  userId          String   @map("user_id")
  trackId         String   @map("track_id")
  playedAt        DateTime @map("played_at") // Cast to TIMESTAMPTZ in post-migration
  msPlayed        Int      @map("ms_played")
  isEstimated     Boolean  @default(true) @map("is_estimated")
  isSkip          Boolean  @default(false) @map("is_skip")
  source          Source   @default(API)
  createdAt       DateTime @default(now()) @map("created_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track           Track    @relation(fields: [trackId], references: [id])

  @@id([id, playedAt]) // Composite PK enables partitioning by playedAt
  @@unique([userId, trackId, playedAt])
  @@index([userId, playedAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([trackId])
  @@map("listening_events")
}

model UserTrackStats {
  userId          String   @map("user_id")
  trackId         String   @map("track_id")
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")
  lastPlayedAt    DateTime? @map("last_played_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track           Track    @relation(fields: [trackId], references: [id])

  @@id([userId, trackId])
  @@index([userId, playCount(sort: Desc)])
  @@index([trackId])
  @@map("user_track_stats")
}

model UserArtistStats {
  userId          String   @map("user_id")
  artistId        String   @map("artist_id")
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist          Artist   @relation(fields: [artistId], references: [id])

  @@id([userId, artistId])
  @@index([userId, playCount(sort: Desc)])
  @@index([artistId])
  @@map("user_artist_stats")
}

model UserTimeBucketStats {
  userId          String     @map("user_id")
  bucketType      BucketType @map("bucket_type")
  bucketDate      DateTime   @map("bucket_date")
  playCount       Int        @default(0) @map("play_count")
  totalMs         BigInt     @default(0) @map("total_ms")
  uniqueTracks    Int        @default(0) @map("unique_tracks")

  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, bucketType, bucketDate])
  @@index([userId, bucketType, bucketDate(sort: Desc)])
  @@map("user_time_bucket_stats")
}

model UserHourStats {
  userId          String   @map("user_id")
  hour            Int
  playCount       Int      @default(0) @map("play_count")
  totalMs         BigInt   @default(0) @map("total_ms")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, hour])
  @@map("user_hour_stats")
}

model ImportJob {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  fileName        String    @map("file_name")
  status          JobStatus @default(PENDING)
  totalEvents     Int       @default(0) @map("total_events")
  processedEvents Int       @default(0) @map("processed_events")
  errorMessage    String?   @map("error_message")
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime  @default(now()) @map("created_at")

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("import_jobs")
}

model PlaylistJob {
  id                  String                 @id @default(cuid())
  userId              String                 @map("user_id")
  creationMethod      PlaylistCreationMethod @map("creation_method")
  status              PlaylistJobStatus      @default(PENDING)
  
  // Input params
  name                String
  isPublic            Boolean                @default(false) @map("is_public")
  coverImageBase64    String?                @map("cover_image_base64")
  
  // Method-specific params
  sourcePlaylistId    String?                @map("source_playlist_id")
  shuffleMode         ShuffleMode?           @map("shuffle_mode")
  kValue              Int?                   @map("k_value")
  startDate           DateTime?              @map("start_date")
  endDate             DateTime?              @map("end_date")

  // Idempotency - derived from confirmation token hash
  idempotencyKey      String?                @unique @map("idempotency_key")
  
  // Progress tracking
  totalTracks         Int                    @default(0) @map("total_tracks")
  addedTracks         Int                    @default(0) @map("added_tracks")
  estimatedTracks     Int?                   @map("estimated_tracks")
  
  // Reliability tracking
  retryCount          Int                    @default(0) @map("retry_count")
  rateLimitDelays     Int                    @default(0) @map("rate_limit_delays")
  lastHeartbeatAt     DateTime?              @map("last_heartbeat_at")
  processingTimeMs    Int?                   @map("processing_time_ms")
  
  // Result
  spotifyPlaylistId   String?                @map("spotify_playlist_id")
  spotifyPlaylistUrl  String?                @map("spotify_playlist_url")
  errorMessage        String?                @map("error_message")
  
  startedAt           DateTime?              @map("started_at")
  completedAt         DateTime?              @map("completed_at")
  createdAt           DateTime               @default(now()) @map("created_at")
  
  user                User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt(sort: Desc)])
  @@map("playlist_jobs")
}

model UserSettings {
  userId              String   @id @map("user_id")
  isPublicProfile     Boolean  @default(false) @map("is_public_profile")
  shareTopTracks      Boolean  @default(true) @map("share_top_tracks")
  shareTopArtists     Boolean  @default(true) @map("share_top_artists")
  shareListeningTime  Boolean  @default(true) @map("share_listening_time")
  emailNotifications  Boolean  @default(false) @map("email_notifications")
  timezone            String   @default("UTC")
  updatedAt           DateTime @updatedAt @map("updated_at")

  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model MetadataRefreshLog {
  id              String   @id @default(cuid())
  entityType      String   @map("entity_type")
  entityId        String   @map("entity_id")
  lastRefreshedAt DateTime @default(now()) @map("last_refreshed_at")
  nextRefreshAt   DateTime? @map("next_refresh_at")
  errorCount      Int      @default(0) @map("error_count")

  @@unique([entityType, entityId])
  @@index([nextRefreshAt])
  @@map("metadata_refresh_log")
}


model SpotifyTopTrack {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  trackId   String   @map("track_id")
  term      Term
  rank      Int
  updatedAt DateTime @updatedAt @map("updated_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  track     Track    @relation(fields: [trackId], references: [id])

  @@unique([userId, term, rank])
  @@unique([userId, term, trackId])
  @@index([trackId])
  @@map("spotify_top_tracks")
}

model SpotifyTopArtist {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  artistId  String   @map("artist_id")
  term      Term
  rank      Int
  updatedAt DateTime @updatedAt @map("updated_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist    Artist   @relation(fields: [artistId], references: [id])

  @@unique([userId, term, rank])
  @@unique([userId, term, artistId])
  @@index([artistId])
  @@map("spotify_top_artists")
}

model TrackResolutionCache {
  id              String   @id @default(cuid())
  trackName       String   @map("track_name")
  artistName      String   @map("artist_name")
  normalizedKey   String   @unique @map("normalized_key")
  spotifyTrackId  String?  @map("spotify_track_id")
  resolvedAt      DateTime @default(now()) @map("resolved_at")

  @@index([normalizedKey])
  @@map("track_resolution_cache")
}
